import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { CHAIN_NAMESPACES, SOLANA_ADAPTERS, EVM_ADAPTERS, WALLET_ADAPTERS, getChainConfig, ADAPTER_CATEGORY, log, ADAPTER_STATUS, ADAPTER_EVENTS } from '@web3auth/base';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _get from '@babel/runtime/helpers/get';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { Web3AuthCore } from '@web3auth/core';
import LoginModal, { getAdapterSocialLogins, OPENLOGIN_PROVIDERS, LOGIN_MODAL_EVENTS } from '@web3auth/ui';

var _adapters, _adapters2;
var defaultSolanaDappModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.SOLANA,
  adapters: (_adapters = {}, _defineProperty(_adapters, SOLANA_ADAPTERS.TORUS_SOLANA, {
    label: "Torus Wallet",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  }), _defineProperty(_adapters, SOLANA_ADAPTERS.OPENLOGIN, {
    label: "OpenLogin",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  }), _defineProperty(_adapters, SOLANA_ADAPTERS.PHANTOM, {
    label: "Phantom",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  }), _adapters)
};
var defaultEvmDappModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.EIP155,
  adapters: (_adapters2 = {}, _defineProperty(_adapters2, EVM_ADAPTERS.TORUS_EVM, {
    label: "Torus Wallet",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  }), _defineProperty(_adapters2, EVM_ADAPTERS.METAMASK, {
    label: "MetaMask",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  }), _defineProperty(_adapters2, EVM_ADAPTERS.OPENLOGIN, {
    label: "OpenLogin",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  }), _defineProperty(_adapters2, EVM_ADAPTERS.WALLET_CONNECT_V1, {
    label: "Wallet Connect",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  }), _adapters2)
};
var defaultSolanaWalletModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.SOLANA,
  adapters: _defineProperty({}, SOLANA_ADAPTERS.OPENLOGIN, {
    label: "OpenLogin",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  })
};
var defaultEvmWalletModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.EIP155,
  adapters: _defineProperty({}, EVM_ADAPTERS.OPENLOGIN, {
    label: "OpenLogin",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  })
};
var defaultOtherModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.OTHER,
  adapters: _defineProperty({}, EVM_ADAPTERS.OPENLOGIN, {
    label: "OpenLogin",
    showOnModal: true,
    showOnMobile: true,
    showOnDesktop: true
  })
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var getDefaultAdapterModule = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(params) {
    var name, customChainConfig, clientId, finalChainConfig, _yield$import, TorusWalletAdapter, adapter, _yield$import2, SolanaWalletAdapter, _adapter, _yield$import3, MetamaskAdapter, _adapter2, _yield$import4, PhantomAdapter, _adapter3, _yield$import5, WalletConnectV1Adapter, _adapter4, _yield$import6, OpenloginAdapter, getOpenloginDefaultOptions, defaultOptions, _adapter5;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            name = params.name, customChainConfig = params.customChainConfig, clientId = params.clientId;

            if (Object.values(CHAIN_NAMESPACES).includes(customChainConfig.chainNamespace)) {
              _context.next = 3;
              break;
            }

            throw new Error("Invalid chainNamespace: ".concat(customChainConfig.chainNamespace));

          case 3:
            finalChainConfig = _objectSpread$1(_objectSpread$1({}, getChainConfig(customChainConfig.chainNamespace, customChainConfig === null || customChainConfig === void 0 ? void 0 : customChainConfig.chainId)), customChainConfig || {});

            if (!(name === WALLET_ADAPTERS.TORUS_EVM)) {
              _context.next = 13;
              break;
            }

            _context.next = 7;
            return import('@web3auth/torus-evm-adapter');

          case 7:
            _yield$import = _context.sent;
            TorusWalletAdapter = _yield$import.TorusWalletAdapter;
            adapter = new TorusWalletAdapter({
              chainConfig: finalChainConfig,
              clientId: clientId
            });
            return _context.abrupt("return", adapter);

          case 13:
            if (!(name === WALLET_ADAPTERS.TORUS_SOLANA)) {
              _context.next = 22;
              break;
            }

            _context.next = 16;
            return import('@web3auth/torus-solana-adapter');

          case 16:
            _yield$import2 = _context.sent;
            SolanaWalletAdapter = _yield$import2.SolanaWalletAdapter;
            _adapter = new SolanaWalletAdapter({
              chainConfig: finalChainConfig,
              clientId: clientId
            });
            return _context.abrupt("return", _adapter);

          case 22:
            if (!(name === WALLET_ADAPTERS.METAMASK)) {
              _context.next = 31;
              break;
            }

            _context.next = 25;
            return import('@web3auth/metamask-adapter');

          case 25:
            _yield$import3 = _context.sent;
            MetamaskAdapter = _yield$import3.MetamaskAdapter;
            _adapter2 = new MetamaskAdapter({
              chainConfig: finalChainConfig,
              clientId: clientId
            });
            return _context.abrupt("return", _adapter2);

          case 31:
            if (!(name === WALLET_ADAPTERS.PHANTOM)) {
              _context.next = 40;
              break;
            }

            _context.next = 34;
            return import('@web3auth/phantom-adapter');

          case 34:
            _yield$import4 = _context.sent;
            PhantomAdapter = _yield$import4.PhantomAdapter;
            _adapter3 = new PhantomAdapter({
              chainConfig: finalChainConfig,
              clientId: clientId
            });
            return _context.abrupt("return", _adapter3);

          case 40:
            if (!(name === WALLET_ADAPTERS.WALLET_CONNECT_V1)) {
              _context.next = 49;
              break;
            }

            _context.next = 43;
            return import('@web3auth/wallet-connect-v1-adapter');

          case 43:
            _yield$import5 = _context.sent;
            WalletConnectV1Adapter = _yield$import5.WalletConnectV1Adapter;
            _adapter4 = new WalletConnectV1Adapter({
              chainConfig: finalChainConfig,
              clientId: clientId
            });
            return _context.abrupt("return", _adapter4);

          case 49:
            if (!(name === WALLET_ADAPTERS.OPENLOGIN)) {
              _context.next = 58;
              break;
            }

            _context.next = 52;
            return import('@web3auth/openlogin-adapter');

          case 52:
            _yield$import6 = _context.sent;
            OpenloginAdapter = _yield$import6.OpenloginAdapter;
            getOpenloginDefaultOptions = _yield$import6.getOpenloginDefaultOptions;
            defaultOptions = getOpenloginDefaultOptions(customChainConfig.chainNamespace, customChainConfig === null || customChainConfig === void 0 ? void 0 : customChainConfig.chainId);
            _adapter5 = new OpenloginAdapter(_objectSpread$1(_objectSpread$1({}, defaultOptions), {}, {
              chainConfig: _objectSpread$1(_objectSpread$1({}, defaultOptions.chainConfig || {}), finalChainConfig),
              adapterSettings: _objectSpread$1(_objectSpread$1({}, defaultOptions.adapterSettings), {}, {
                clientId: clientId
              })
            }));
            return _context.abrupt("return", _adapter5);

          case 58:
            throw new Error("Invalid wallet adapter name");

          case 59:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getDefaultAdapterModule(_x) {
    return _ref.apply(this, arguments);
  };
}();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var Web3Auth = /*#__PURE__*/function (_Web3AuthCore) {
  _inherits(Web3Auth, _Web3AuthCore);

  var _super = _createSuper(Web3Auth);

  function Web3Auth(options) {
    var _this$options$uiConfi, _this$options$uiConfi2;

    var _this;

    _classCallCheck(this, Web3Auth);

    _this = _super.call(this, options);

    _defineProperty(_assertThisInitialized(_this), "loginModal", void 0);

    _defineProperty(_assertThisInitialized(_this), "options", void 0);

    _defineProperty(_assertThisInitialized(_this), "modalConfig", defaultEvmDappModalConfig);

    _this.options = _objectSpread({}, options);
    var providedChainConfig = _this.options.chainConfig;

    if (providedChainConfig.chainNamespace === CHAIN_NAMESPACES.SOLANA) {
      if (options.authMode === "WALLET") {
        // default config for solana wallet modal
        _this.modalConfig = defaultSolanaWalletModalConfig;
      } else {
        // default config for solana dapp modal
        _this.modalConfig = defaultSolanaDappModalConfig;
      }
    } else if (providedChainConfig.chainNamespace === CHAIN_NAMESPACES.EIP155) {
      if (options.authMode === "WALLET") {
        // default config for evm wallet modal
        _this.modalConfig = defaultEvmWalletModalConfig;
      } else {
        // default config for evm dapp modal
        _this.modalConfig = defaultEvmDappModalConfig;
      }
    } else if (providedChainConfig.chainNamespace === CHAIN_NAMESPACES.OTHER) {
      _this.modalConfig = defaultOtherModalConfig;
    } else {
      throw new Error("Invalid chainNamespace provided: ".concat(providedChainConfig.chainNamespace));
    }

    _this.loginModal = new LoginModal({
      theme: (_this$options$uiConfi = _this.options.uiConfig) === null || _this$options$uiConfi === void 0 ? void 0 : _this$options$uiConfi.theme,
      appLogo: ((_this$options$uiConfi2 = _this.options.uiConfig) === null || _this$options$uiConfi2 === void 0 ? void 0 : _this$options$uiConfi2.appLogo) || "",
      version: "",
      adapterListener: _assertThisInitialized(_this),
      displayErrorsOnModal: _this.options.displayErrorsOnModal
    });

    _this.subscribeToLoginModalEvents();

    return _this;
  }

  _createClass(Web3Auth, [{
    key: "initModal",
    value: function () {
      var _initModal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {
        var _this2 = this;

        var providedChainConfig, allAdapters, adapterConfigurationPromises, adapterNames, hasInAppWallets, initPromises, hasExternalWallets;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _get(_getPrototypeOf(Web3Auth.prototype), "checkInitRequirements", this).call(this);

                _context3.next = 3;
                return this.loginModal.initModal();

              case 3:
                providedChainConfig = this.options.chainConfig; // merge default adapters with the custom configured adapters.

                allAdapters = _toConsumableArray(new Set([].concat(_toConsumableArray(Object.keys(this.modalConfig.adapters || {})), _toConsumableArray(Object.keys(this.walletAdapters)))));
                adapterConfigurationPromises = allAdapters.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(adapterName) {
                    var _this2$modalConfig$ad, _params$modalConfig, _this2$modalConfig$ad2, _this2$modalConfig$ad3;

                    var adapterConfig, adapter, ad, _this2$modalConfig$ad4, _this2$coreOptions$ch, chainConfig;

                    return _regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            // start with the default config of adapter.
                            adapterConfig = ((_this2$modalConfig$ad = _this2.modalConfig.adapters) === null || _this2$modalConfig$ad === void 0 ? void 0 : _this2$modalConfig$ad[adapterName]) || {
                              label: adapterName,
                              showOnModal: true,
                              showOnMobile: true,
                              showOnDesktop: true
                            }; // override the default config of adapter if some config is being provided by the user.

                            if (params !== null && params !== void 0 && (_params$modalConfig = params.modalConfig) !== null && _params$modalConfig !== void 0 && _params$modalConfig[adapterName]) {
                              adapterConfig = _objectSpread(_objectSpread({}, adapterConfig), params.modalConfig[adapterName]);
                            }

                            _this2.modalConfig.adapters[adapterName] = adapterConfig; // check if adapter is configured/added by user and exist in walletAdapters map.

                            adapter = _this2.walletAdapters[adapterName];
                            log.debug("adapter config", adapterName, (_this2$modalConfig$ad2 = _this2.modalConfig.adapters) === null || _this2$modalConfig$ad2 === void 0 ? void 0 : _this2$modalConfig$ad2[adapterName].showOnModal, adapter); // if adapter is not custom configured then check if it is available in default adapters.
                            // and if adapter is not hidden by user

                            if (!(!adapter && (_this2$modalConfig$ad3 = _this2.modalConfig.adapters) !== null && _this2$modalConfig$ad3 !== void 0 && _this2$modalConfig$ad3[adapterName].showOnModal)) {
                              _context.next = 13;
                              break;
                            }

                            _context.next = 8;
                            return getDefaultAdapterModule({
                              name: adapterName,
                              customChainConfig: _this2.options.chainConfig,
                              clientId: _this2.options.clientId
                            });

                          case 8:
                            ad = _context.sent;
                            _this2.walletAdapters[adapterName] = ad;
                            return _context.abrupt("return", adapterName);

                          case 13:
                            if (!((adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.IN_APP || (adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.EXTERNAL || adapterName === _this2.cachedAdapter)) {
                              _context.next = 19;
                              break;
                            }

                            if ((_this2$modalConfig$ad4 = _this2.modalConfig.adapters) !== null && _this2$modalConfig$ad4 !== void 0 && _this2$modalConfig$ad4[adapterName].showOnModal) {
                              _context.next = 16;
                              break;
                            }

                            return _context.abrupt("return");

                          case 16:
                            // add client id to adapter, same web3auth client id can be used in adapter.
                            // this id is being overridden if user is also passing client id in adapter's constructor.
                            _this2.walletAdapters[adapterName].setAdapterSettings({
                              clientId: _this2.options.clientId,
                              sessionTime: _this2.options.sessionTime
                            }); // if adapter doesn't have any chainConfig then we will set the chainConfig based of passed chainNamespace
                            // and chainNamespace.


                            if (!adapter.chainConfigProxy) {
                              chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, (_this2$coreOptions$ch = _this2.coreOptions.chainConfig) === null || _this2$coreOptions$ch === void 0 ? void 0 : _this2$coreOptions$ch.chainId)), _this2.coreOptions.chainConfig);

                              _this2.walletAdapters[adapterName].setChainConfig(chainConfig);
                            }

                            return _context.abrupt("return", adapterName);

                          case 19:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x2) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context3.next = 8;
                return Promise.all(adapterConfigurationPromises);

              case 8:
                adapterNames = _context3.sent;
                hasInAppWallets = Object.values(this.walletAdapters).some(function (adapter) {
                  var _this2$modalConfig$ad5;

                  if (adapter.type !== ADAPTER_CATEGORY.IN_APP) return false;
                  if (_this2.modalConfig.adapters[adapter.name].showOnModal !== true) return false;
                  if (!_this2.modalConfig.adapters[adapter.name].loginMethods) return true;
                  var mergedLoginMethods = getAdapterSocialLogins(adapter.name, _this2.walletAdapters[adapter.name], (_this2$modalConfig$ad5 = _this2.modalConfig.adapters[adapter.name]) === null || _this2$modalConfig$ad5 === void 0 ? void 0 : _this2$modalConfig$ad5.loginMethods);
                  if (Object.values(mergedLoginMethods).some(function (method) {
                    return method.showOnModal;
                  })) return true;
                  return false;
                });
                log.debug(hasInAppWallets, this.walletAdapters, "hasInAppWallets"); // Now, initialize the adapters.

                initPromises = adapterNames.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(adapterName) {
                    var adapter;
                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (adapterName) {
                              _context2.next = 2;
                              break;
                            }

                            return _context2.abrupt("return");

                          case 2:
                            _context2.prev = 2;
                            adapter = _this2.walletAdapters[adapterName]; // only initialize a external adapter here if it is a cached adapter.

                            if (!(_this2.cachedAdapter !== adapterName && adapter.type === ADAPTER_CATEGORY.EXTERNAL)) {
                              _context2.next = 6;
                              break;
                            }

                            return _context2.abrupt("return");

                          case 6:
                            // in-app wallets or cached wallet (being connected or already connected) are initialized first.
                            // if adapter is configured thn only initialize in app or cached adapter.
                            // external wallets are initialized on INIT_EXTERNAL_WALLET event.
                            _this2.subscribeToAdapterEvents(adapter);

                            if (!(adapter.status === ADAPTER_STATUS.NOT_READY)) {
                              _context2.next = 10;
                              break;
                            }

                            _context2.next = 10;
                            return adapter.init({
                              autoConnect: _this2.cachedAdapter === adapterName
                            });

                          case 10:
                            // note: not adding cachedWallet to modal if it is external wallet.
                            // adding it later if no in-app wallets are available.
                            if (adapter.type === ADAPTER_CATEGORY.IN_APP) {
                              _this2.initializeInAppWallet(adapterName);
                            }

                            _context2.next = 16;
                            break;

                          case 13:
                            _context2.prev = 13;
                            _context2.t0 = _context2["catch"](2);
                            log.error(_context2.t0, "error while initializing adapter");

                          case 16:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[2, 13]]);
                  }));

                  return function (_x3) {
                    return _ref2.apply(this, arguments);
                  };
                }());
                this.status = ADAPTER_STATUS.READY;
                _context3.next = 15;
                return Promise.all(initPromises);

              case 15:
                hasExternalWallets = allAdapters.some(function (adapterName) {
                  var _this2$walletAdapters, _this2$modalConfig$ad6;

                  return ((_this2$walletAdapters = _this2.walletAdapters[adapterName]) === null || _this2$walletAdapters === void 0 ? void 0 : _this2$walletAdapters.type) === ADAPTER_CATEGORY.EXTERNAL && ((_this2$modalConfig$ad6 = _this2.modalConfig.adapters) === null || _this2$modalConfig$ad6 === void 0 ? void 0 : _this2$modalConfig$ad6[adapterName].showOnModal);
                });

                if (hasExternalWallets) {
                  this.loginModal.initExternalWalletContainer();
                } // variable to check if we have any in app wallets
                // currently all default in app and external wallets can be hidden or shown based on config.


                if (!(!hasInAppWallets && hasExternalWallets)) {
                  _context3.next = 20;
                  break;
                }

                _context3.next = 20;
                return this.initExternalWalletAdapters(false, {
                  showExternalWalletsOnly: true
                });

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function initModal(_x) {
        return _initModal.apply(this, arguments);
      }

      return initModal;
    }()
  }, {
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this3 = this;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.provider) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", this.provider);

              case 2:
                this.loginModal.open();
                return _context4.abrupt("return", new Promise(function (resolve, reject) {
                  _this3.once(ADAPTER_EVENTS.CONNECTED, function () {
                    return resolve(_this3.provider);
                  });

                  _this3.once(ADAPTER_EVENTS.ERRORED, function (err) {
                    return reject(err);
                  });
                }));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function connect() {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "initExternalWalletAdapters",
    value: function () {
      var _initExternalWalletAdapters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(externalWalletsInitialized, options) {
        var _this4 = this;

        var adaptersConfig, adaptersData, adapterPromises, adapterInitResults, finalAdaptersConfig;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!externalWalletsInitialized) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                adaptersConfig = {};
                adaptersData = {};
                adapterPromises = Object.keys(this.walletAdapters).map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(adapterName) {
                    var adapter;
                    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.prev = 0;
                            adapter = _this4.walletAdapters[adapterName];

                            if (!((adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.EXTERNAL)) {
                              _context5.next = 11;
                              break;
                            }

                            log.debug("init external wallet", _this4.cachedAdapter, adapterName);

                            _this4.subscribeToAdapterEvents(adapter); // we are not initializing cached adapter here as it is already being initialized in initModal before.


                            if (!(_this4.cachedAdapter === adapterName)) {
                              _context5.next = 7;
                              break;
                            }

                            return _context5.abrupt("return");

                          case 7:
                            if (!(adapter.status === ADAPTER_STATUS.NOT_READY)) {
                              _context5.next = 11;
                              break;
                            }

                            _context5.next = 10;
                            return Promise.race([adapter.init({
                              autoConnect: _this4.cachedAdapter === adapterName
                            }).then(function () {
                              adaptersConfig[adapterName] = _this4.modalConfig.adapters[adapterName];
                              adaptersData[adapterName] = adapter.adapterData || {};
                              return adapterName;
                            }), new Promise(function (resolve) {
                              setTimeout(function () {
                                return resolve(null);
                              }, 5000);
                            })]);

                          case 10:
                            return _context5.abrupt("return", _context5.sent);

                          case 11:
                            _context5.next = 16;
                            break;

                          case 13:
                            _context5.prev = 13;
                            _context5.t0 = _context5["catch"](0);
                            log.error(_context5.t0, "error while initializing adapter");

                          case 16:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5, null, [[0, 13]]);
                  }));

                  return function (_x6) {
                    return _ref3.apply(this, arguments);
                  };
                }());
                _context6.next = 7;
                return Promise.all(adapterPromises);

              case 7:
                adapterInitResults = _context6.sent;
                finalAdaptersConfig = {};
                adapterInitResults.forEach(function (result) {
                  if (result) {
                    finalAdaptersConfig[result] = adaptersConfig[result];
                  }
                });
                this.loginModal.addWalletLogins(finalAdaptersConfig, {
                  showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly)
                });

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function initExternalWalletAdapters(_x4, _x5) {
        return _initExternalWalletAdapters.apply(this, arguments);
      }

      return initExternalWalletAdapters;
    }()
  }, {
    key: "initializeInAppWallet",
    value: function initializeInAppWallet(adapterName) {
      log.info("adapterInitResults", adapterName);

      if (this.walletAdapters[adapterName].type === ADAPTER_CATEGORY.IN_APP) {
        var _this$modalConfig$ada, _this$options$uiConfi3;

        this.loginModal.addSocialLogins(adapterName, getAdapterSocialLogins(adapterName, this.walletAdapters[adapterName], (_this$modalConfig$ada = this.modalConfig.adapters[adapterName]) === null || _this$modalConfig$ada === void 0 ? void 0 : _this$modalConfig$ada.loginMethods), ((_this$options$uiConfi3 = this.options.uiConfig) === null || _this$options$uiConfi3 === void 0 ? void 0 : _this$options$uiConfi3.loginMethodsOrder) || OPENLOGIN_PROVIDERS);
      }
    }
  }, {
    key: "subscribeToLoginModalEvents",
    value: function subscribeToLoginModalEvents() {
      var _this5 = this;

      this.loginModal.on(LOGIN_MODAL_EVENTS.LOGIN, /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(params) {
          return _regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.prev = 0;
                  _context7.next = 3;
                  return _this5.connectTo(params.adapter, params.loginParams);

                case 3:
                  _context7.next = 8;
                  break;

                case 5:
                  _context7.prev = 5;
                  _context7.t0 = _context7["catch"](0);
                  log.error("Error while connecting to adapter: ".concat(params.adapter), _context7.t0);

                case 8:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[0, 5]]);
        }));

        return function (_x7) {
          return _ref4.apply(this, arguments);
        };
      }());
      this.loginModal.on(LOGIN_MODAL_EVENTS.INIT_EXTERNAL_WALLETS, /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(params) {
          return _regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _context8.next = 2;
                  return _this5.initExternalWalletAdapters(params.externalWalletsInitialized);

                case 2:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }));

        return function (_x8) {
          return _ref5.apply(this, arguments);
        };
      }());
      this.loginModal.on(LOGIN_MODAL_EVENTS.DISCONNECT, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return _this5.logout();

              case 3:
                _context9.next = 8;
                break;

              case 5:
                _context9.prev = 5;
                _context9.t0 = _context9["catch"](0);
                log.error("Error while disconnecting", _context9.t0);

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, null, [[0, 5]]);
      })));
      this.loginModal.on(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(visibility) {
          var _this5$walletAdapters;

          var walletConnectStatus;
          return _regeneratorRuntime.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  log.debug("is login modal visible", visibility);

                  _this5.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, visibility);

                  walletConnectStatus = (_this5$walletAdapters = _this5.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1]) === null || _this5$walletAdapters === void 0 ? void 0 : _this5$walletAdapters.status;

                  if (visibility && walletConnectStatus === ADAPTER_STATUS.READY) {
                    // refreshing session for wallet connect whenever modal is opened.
                    try {
                      _this5.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1].connect();
                    } catch (error) {
                      log.error("Error while disconnecting to wallet connect in core", error);
                    }
                  }

                case 4:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));

        return function (_x9) {
          return _ref7.apply(this, arguments);
        };
      }());
    }
  }]);

  return Web3Auth;
}(Web3AuthCore);

export { Web3Auth, defaultEvmDappModalConfig, defaultEvmWalletModalConfig, defaultOtherModalConfig, defaultSolanaDappModalConfig, defaultSolanaWalletModalConfig };
//# sourceMappingURL=web3auth.esm.js.map
